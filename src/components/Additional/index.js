import React from 'react';
import ContainerComponent from "../ContainerComponent";
import ComponentsImage from '../../assets/compnents.png';
import Flux from '../../assets/flux.png';
import MVC from '../../assets/mvc.png';

export default function Additional() {
  return (
    <>
    <h3>Дополнительные материалы</h3>
      <ContainerComponent title={'Progressive Web Application (PWA)'}>
        <p>PWA – это веб-сайт, созданный с использованием веб-технологий,
          который действует как мобильное приложение и не требует установки как собственное приложение.</p>
        <p>
        Используя новейшие функции браузера, реализуются собственные типичные для мобильных приложений возможности и функции.
          Запущенные в отдельном окне браузера без адресной строки, они визуально и функционально почти неотличимы от приложений.
          PWA должен быть разработан для поддержания базовой функциональности,
          даже если он работает в автономном режиме или в браузере, который не поддерживает некоторые функции.
        </p>
      </ContainerComponent>


      <ContainerComponent title={'Flux архитектура'}>
        <p>
          При использовании приложения часто происходят изменения в его состоянии, от которого зависит отображение отдельных модулей. При небольших размерах проекта состояние может храниться внутри компонентов и передаваться потомкам, однако такой способ абсолютно не подходит для крупных проектов.
          Решением данной проблемы является flux-архитектура, которая включает в себя следующие элементы:
          <span className='p-1 d-flex w-100'>-cостояние (store), «источник истины»,</span>
          <span className='p-1 d-flex w-100'>-представление, отображает состояние,</span>
          <span className='p-1 d-flex w-100'>-действия, которые могут изменить состояние, после взаимодействия с представлением.</span>
        </p>
        <img src={Flux}/>
      </ContainerComponent>


      <ContainerComponent title={'Single Page Application (SPA)'}>
        <p>SPA (single page application) – это современный подход к разработке веб-приложений,
          используется для разработки простых приложений с меньшим количеством контента.
          Данный вид веб-приложений представляет только одну страницу, которая является основой для всех частей приложения.
          Сопутствующие приложению файлы CSS стилей, HTML разметки, JavaScript кода загружаются только один раз за время
          работы приложения</p>
        <p>
        После первоначального запроса к серверу браузер загружает полную HTML-страницу.
          Каждое последующее взаимодействие клиента и сервера выполняется с использованием техники AJAX,
          что означает, что браузер обновляет только часть страницы, которая изменяется (данные), не обновляя всю страницу.
          Использование модели SPA снижает скорость загрузки приложений и улучшает взаимодействие с пользователем.
          </p>
        <p>
        Слабой стороной SPA приложений является SEO оптимизация, которая влияет на рейтинг веб-сайта в поисковых системах,
          что негативно сказывается на продвижении сайта в поисковой выдаче.
          Из-за особенности концепции единой HTML страницы становится невозможным широкое описание страниц сайта с
          помощью мета-тегов. Ряд фреймворков предлагают решения данной проблемы через имплементацию Server Side Rendering.</p>
      </ContainerComponent>
      <ContainerComponent title={'Server Side Rendering (SSR)'}>
        <p>SSR (Server-Side Rendering, серверный рендеринг) — рендеринг на сервере клиентской части или универсального приложения в HTML;</p>
        <p>Одной из самых больших проблем использования SPA является SEO оптимизация и продвижение, а если веб-приложение нуждается в поисковой оптимизации, то целесообразно рассмотреть MPA или фреймворки с поддержкой SSR.</p>
      </ContainerComponent>
      <ContainerComponent title={'Компонентный подход'}>
        <p>Компоненты являются основными строительными блоками приложения.
          Способ инициализации и обработки компонентов варьируется в разных фреймворках,
          но основные характеристики одинаковы: компоненты могут принимать информацию в качестве параметров,
          выполнять действия и, возможно, возвращать некоторый результат.
          Компоненты взаимодействуют друг с другом, могут использовать свойства друг друга
          и могут иметь родительские или дочерние компоненты.</p>

        <p>
          Одни компоненты могут быть невидимы для пользователя,
          выполняя только обработку данных или другого вида логику,
          другие компоненты могут работать с пользовательским интерфейсом,
          представлением, конфигурируя HTML-документ.
          Некоторые фреймворки используют специальный синтаксис, который создает HTML-шаблоны,
          что позволяет брать такие шаблоны в качестве входных данных, вносить в них изменения,
          повторно использовать их в разных частях приложения для отображения данных.
        </p>

        <p>
          Компоненты могут обмениваться данными с сервером с помощью AJAX-запросов.
          AJAX предоставляет асинхронные запросы на передачу данных,
          так что приложение может динамически обновлять содержимое страницы без необходимости перезагрузки.
          Компоненты могут, например, получить больше строк в таблице данных из-за действия пользователя.
        </p>
        <span className={'w-100 d-flex'}>Пример возможных связей между компонентами</span>
        <img src={ComponentsImage}/>
      </ContainerComponent>
      <ContainerComponent title={'Multi Page Application (MPA)'}>
        <p>MPA (multi page application) хорошо подходит для более крупных систем с множеством различных сервисов,
          которые подразумевают разные типы взаимодействия между пользователями. Большая часть логики таких приложений находится
          на сервере. Маршруты данного вида приложений регистрируются на серверной части, по HTTP-запросу передаются HTML страницы.
        </p>
      </ContainerComponent>

      <ContainerComponent title={'MVC pattern'}>
        <p>
          Целью паттерна MVC является динамическое программирование,
          при котором упрощается модификация и расширение приложения,
          а также делается возможным повторное использование каких-либо частей кода.
          Данный паттерн упрощает сложность программы и делает ее структуру интуитивно понятной.
        </p>
        <p>Взаимодействие пользователя с MVC приложением происходит привычным образом.
          Пользователь выполняет действие, в ответ на которое приложение изменяет свою модель данных
          и показывает обновленное представление. Такой вид взаимодействия хорошо сочетается
          с взаимодействием клиентской части приложения с серверной, которое происходит через HTTP запросы.</p>

        <span className='p-1 d-flex w-100'>-модель (Model, бизнес-логика), используется для инкапсуляции данных, связанных с бизнес-логикой приложения и способа обработки данных. Должна быть абсолютно независима от других частей приложения. «Модель» имеет право на прямой доступ к данным, к базе данных,</span>
        <span className='p-1 d-flex w-100'>-представление (View, пользовательский интерфейс), имеет доступ только для чтения данных из модели, обновляет отображение на экране, взаимодействует с пользователем. Отвечает за внешний вид приложения,</span>
        <span className='p-1 d-flex w-100'>-контроллер (Controller, сервер), реагирует на запросы и действия, в зависимости от события меняет и обновляет модель</span>
        <img src={MVC}/>
      </ContainerComponent>

      <ContainerComponent title={'VCS'}>
        <p>
          VCS (Versions control system) - система контроля версий.
        </p>
      </ContainerComponent>

      <ContainerComponent title={'Виды организации VCS'}>
        <p>
          Для разработки масштабных проектов, которые включают в себя множество связанных между собой сервисов, существует несколько способов проектирования работы с системой контроля версий. К таким способам относятся:
          <span className='p-1 d-flex w-100'>-мультипрепозитории (polyrepo), один репозиторий для всех библиотек и компонентов,</span>
          <span className='p-1 d-flex w-100'>-монорепозитории (monorepo), один репозиторий для всей компании или для значительного числа проектов,</span>
          <span className='p-1 d-flex w-100'>-гибрид мульти как моно (hybrid-poly-as-mono), обновления делаются в нескольких репозиториях, но управляются как монорепозиторий,</span>
          <span className='p-1 d-flex w-100'>-гибрид моно как мульти (hybrid-mono-as-poly), обновления делаются в монорепозитории, но затем разделяются на полирепозитории только для чтения, для целей сборки или развертывания.</span>
        </p>
      </ContainerComponent>

      <ContainerComponent title={'Virtual DOM'}>
        <p>
          Virtual DOM - концепция, в которой идеальное представление пользовательского интерфейса хранится в памяти и синхронизируется с настоящим DOM-деревом. Это значительно оптимизирует процесс рендеринга изменений на веб-странице и повышает общую производительность.
        </p>
        <a href={'https://reactjs.org/docs/faq-internals.html'}>https://reactjs.org/docs/faq-internals.html</a>
      </ContainerComponent>

    </>
  )
}